####学习笔记
##### Trie 字典树
##### 字符串搜索、如何创建一个Trie树
#####并查集
- 什么是并查集
- 并查集能干什么
- 并查集的模板？
- 如何一眼识别某个题目用并查集更优？
#####优化算法，包括剪枝
#####高级搜索：A*（智能化）、双向BFS
- 经典的双向BFS的解法
#####平衡树
- 如何理解平衡
- 常见的平衡树有哪些？（包括严格的平衡和近似的平衡）
- AVL树
  -  树的定义（限定条件），重点理解平衡因子 balance factor -> {-1, 0, 1}
  -  常见的四种自平衡的手段  -> 旋转
     - 左左子树 -> 右旋一次
     - 右右子树 -> 左旋一次
     - 左右子树 -> 右左旋
     - 右左子树 -> 左右旋
  - 特性：
     - 严格的自平衡，导致其查询更方便，树的深度层级不会差太多
     - 每次的插入和删除有很大的概率触发自平衡操作，会更费时间去实现树的自平衡上
     
 - 近似平衡树（如红黑树）
   - 定义条件：
     - 树的最大深度不超过最小深度的2倍
     - 跟为黑色节点
     - 红黑节点交替
     - 红黑节点不能相邻
     - 每一层上的红黑节点的个数一致
   - 特性：
     - 更少的自平衡操作，意味着插入和删除过程中节约了自平衡的时间
     - 常见于各个语言的功能库中，像是java8中的改版，相对于java7使用了红黑树
       - 当entry上的链表节点个数超过7个时，链表就自动转换为红黑树，猜想是为了更快的进行数据的插入和删除操作，
       当然，自平衡又能很好地解决了特殊场景下的树退化成链表的问题
       
 -  AVL和红黑树有什么异同？
    - 树的结构（可理解为满足条件），或者抽象为严格的自平衡和近似的自平衡
    - 针对数据的查询、插入和删除操作的影响
      - 严格的自平衡当然是有了利于数据的查询，但是也会花费更多的时间在于本身树结构的自平衡上
      - 近似的自平衡能有效地缓解严格自平衡树的删除、插入操作带来的额外的自平衡耗时问题，但也对查询的性能做出了妥协
    - 应用场景：
      - AVL树一般广泛用于数据库等查询要求性能高的场景，当然还有B-、B+等也是，
      一方面尽可能减少树的层级深度，另一方面也尽量保证数据的连续
      - 近似的自平衡树广泛应用于语言库中的map里面
  